/** * <p>Title: ReflectionUtils.java</p> * <p>Description: </p> * <p>Copyright: Copyright (C) 2011 YSL. All rights reserved. </p>  * <p>Company: </p> * @author zhanglei<zhanglei_job_email@163.com> * @date 2011-5-15 * @version 1.0 */package com.google.ysl.framework.common.util;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collection;import java.util.Date;import java.util.List;import org.apache.commons.beanutils.ConvertUtils;import org.apache.commons.beanutils.PropertyUtils;import org.apache.commons.beanutils.converters.DateConverter;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.Assert;/** * <p>Title: ReflectionUtils</p> * <p>Description:  * 反射的Utils函数集合. * 提供访问私有变量,获取泛型类型Class,提取集合中元素的属性等Utils函数. * </p> * <p>Company: </p>  * @author zhanglei<zhanglei_job_email@163.com> * @date 2011-5-15 * */public final class ReflectionUtils {	private static Logger logger = LoggerFactory			.getLogger(ReflectionUtils.class);	/**	 * <p>Title: Constructor.</p>	 * <p>Description: </p>	 */	private ReflectionUtils() {		super();	}	/**	 * <p>Title: getFieldValue</p>	 * <p>Description: 直接读取对象属性值,无视private/protected修饰符,不经过getter函数.</p>	 * @param object	 * @param fieldName	 * @return Object	 * @throws	 *	 */	public static Object getFieldValue(final Object object,			final String fieldName) {		Field field = getDeclaredField(object, fieldName);		if (field == null)			throw new IllegalArgumentException("Could not find field ["					+ fieldName + "] on target [" + object + "]");		makeAccessible(field);		Object result = null;		try {			result = field.get(object);		} catch (IllegalAccessException e) {			logger.error("不可能抛出的异常{}", e.getMessage());		}		return result;	}	/**	 * <p>Title: setFieldValue</p>	 * <p>Description: 直接设置对象属性值,无视private/protected修饰符,不经过setter函数.</p>	 * @param object	 * @param fieldName	 * @param value	 * @return void	 * @throws	 *	 */	public static void setFieldValue(final Object object,			final String fieldName, final Object value) {		Field field = getDeclaredField(object, fieldName);		if (field == null)			throw new IllegalArgumentException("Could not find field ["					+ fieldName + "] on target [" + object + "]");		makeAccessible(field);		try {			field.set(object, value);		} catch (IllegalAccessException e) {			logger.error("不可能抛出的异常:{}", e.getMessage());		}	}	/**	 * <p>Title: invokeMethod</p>	 * <p>Description: 直接调用对象方法,无视private/protected修饰符.</p>	 * @param object	 * @param methodName	 * @param parameterTypes	 * @param parameters	 * @return Object	 * @throws InvocationTargetException	 *	 */	public static Object invokeMethod(final Object object,			final String methodName, final Class<?>[] parameterTypes,			final Object[] parameters) throws InvocationTargetException {		Method method = getDeclaredMethod(object, methodName, parameterTypes);		if (method == null)			throw new IllegalArgumentException("Could not find method ["					+ methodName + "] on target [" + object + "]");		method.setAccessible(true);		try {			return method.invoke(object, parameters);		} catch (IllegalAccessException e) {			logger.error("不可能抛出的异常:{}", e.getMessage());		}		return null;	}	/**	 * <p>Title: getDeclaredField</p>	 * <p>Description: 循环向上转型,获取对象的DeclaredField.</p>	 * @param object	 * @param fieldName	 * @return Field	 * @throws	 *	 */	protected static Field getDeclaredField(final Object object,			final String fieldName) {		Assert.notNull(object, "object不能为空");		Assert.hasText(fieldName, "fieldName");		for (Class<?> superClass = object.getClass(); superClass != Object.class; superClass = superClass				.getSuperclass()) {			try {				return superClass.getDeclaredField(fieldName);			} catch (NoSuchFieldException e) {				// Field不在当前类定义,继续向上转型			}		}		return null;	}	/**	 * <p>Title: makeAccessible</p>	 * <p>Description: 循环向上转型,获取对象的DeclaredField.</p>	 * @param field	 * @return void	 * @throws	 *	 */	protected static void makeAccessible(final Field field) {		if (!Modifier.isPublic(field.getModifiers())				|| !Modifier.isPublic(field.getDeclaringClass().getModifiers())) {			field.setAccessible(true);		}	}	/**	 * <p>Title: getDeclaredMethod</p>	 * <p>Description: 循环向上转型,获取对象的DeclaredMethod.</p>	 * @param object	 * @param methodName	 * @param parameterTypes	 * @return Method	 * @throws	 *	 */	protected static Method getDeclaredMethod(Object object, String methodName,			Class<?>[] parameterTypes) {		Assert.notNull(object, "object不能为空");		for (Class<?> superClass = object.getClass(); superClass != Object.class; superClass = superClass				.getSuperclass()) {			try {				return superClass.getDeclaredMethod(methodName, parameterTypes);			} catch (NoSuchMethodException e) {				// Method不在当前类定义,继续向上转型			}		}		return null;	}	/**	 * <p>Title: getSuperClassGenricType</p>	 * <p>Description: 通过反射,获得Class定义中声明的父类的泛型参数的类型.</p>	 * @param <T>	 * @param clazz	 * @return Class<T>	 * @throws	 *	 */	public static <T> Class<T> getSuperClassGenricType(final Class clazz) {		return getSuperClassGenricType(clazz, 0);	}	/**	 * <p>Title: getSuperClassGenricType</p>	 * <p>Description: 通过反射,获得定义Class时声明的父类的泛型参数的类型.</p>	 * @param clazz	 * @param index	 * @return Class	 * @throws	 *	 */	public static Class getSuperClassGenricType(final Class clazz,			final int index) {		Type genType = clazz.getGenericSuperclass();		if (!(genType instanceof ParameterizedType)) {			logger.warn(clazz.getSimpleName()					+ "'s superclass not ParameterizedType");			return Object.class;		}		Type[] params = ((ParameterizedType) genType).getActualTypeArguments();		if (index >= params.length || index < 0) {			logger.warn("Index: " + index + ", Size of "					+ clazz.getSimpleName() + "'s Parameterized Type: "					+ params.length);			return Object.class;		}		if (!(params[index] instanceof Class)) {			logger.warn(clazz.getSimpleName()					+ " not set the actual class on superclass generic parameter");			return Object.class;		}		return (Class) params[index];	}	/**	 * <p>Title: fetchElementPropertyToList</p>	 * <p>Description: 提取集合中的对象的属性(通过getter函数),组合成List.</p>	 * @param collection	 * @param propertyName	 * @return List	 * @throws	 *	 */	public static List fetchElementPropertyToList(final Collection collection,			final String propertyName) {		List list = new ArrayList();		try {			for (Object obj : collection) {				list.add(PropertyUtils.getProperty(obj, propertyName));			}		} catch (Exception e) {			convertToUncheckedException(e);		}		return list;	}	/**	 * <p>Title: fetchElementPropertyToString</p>	 * <p>Description: 提取集合中的对象的属性(通过getter函数),组合成由分割符分隔的字符串.</p>	 * @param collection	 * @param propertyName	 * @param separator	 * @return String	 * @throws	 *	 */	public static String fetchElementPropertyToString(			final Collection collection, final String propertyName,			final String separator) {		List list = fetchElementPropertyToList(collection, propertyName);		return StringUtils.join(list, separator);	}	/**	 * <p>Title: convertValue</p>	 * <p>Description: 转换字符串类型到clazz的property类型的值.</p>	 * @param value	 * @param toType	 * @return Object	 * @throws	 *	 */	public static Object convertValue(Object value, Class<?> toType) {		try {			DateConverter dc = new DateConverter();			dc.setUseLocaleFormat(true);			dc.setPatterns(new String[] { "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss" });			ConvertUtils.register(dc, Date.class);			return ConvertUtils.convert(value, toType);		} catch (Exception e) {			throw convertToUncheckedException(e);		}	}	/**	 * <p>Title: convertToUncheckedException</p>	 * <p>Description: 将反射时的checked exception转换为unchecked exception.</p>	 * @param e	 * @return RuntimeException	 * @throws	 *	 */	public static RuntimeException convertToUncheckedException(Exception e) {		if (e instanceof IllegalAccessException				|| e instanceof IllegalArgumentException				|| e instanceof NoSuchMethodException) {			return new IllegalArgumentException("Reflection Exception.", e);		} else if (e instanceof InvocationTargetException) {			return new RuntimeException("Reflection Exception.",					((InvocationTargetException) e).getTargetException());		} else if (e instanceof RuntimeException) {			return (RuntimeException) e;		}		return new RuntimeException("Unexpected Checked Exception.", e);	}}